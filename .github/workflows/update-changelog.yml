# Automatically update CHANGELOG.md when PR is merged to staging
# Summarizes commit messages from the PR and adds them to the changelog
name: Update Changelog

on:
  pull_request:
    types: [closed]
    branches:
      - staging

jobs:
  update-changelog:
    # Only run if PR was actually merged (not just closed)
    if: github.event.pull_request.merged == true
    name: Generate and Update Changelog
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For committing changes

    steps:
    - name: Checkout staging branch
      uses: actions/checkout@v4
      with:
        ref: staging
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install uv
      uses: astral-sh/setup-uv@v5
      with:
        enable-cache: true
        cache-dependency-glob: "pyproject.toml"

    - name: Install OpenAI package
      run: |
        uv pip install --system openai

    - name: Get version from pyproject.toml
      id: get_version
      run: |
        python3 << 'EOF' > version.txt
        import re
        with open('pyproject.toml') as f:
            content = f.read()
        match = re.search(r'^version\s*=\s*["\']([^"\']+)["\']', content, re.MULTILINE)
        print(match.group(1))
        EOF
        VERSION=$(cat version.txt)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Version: $VERSION"

    - name: Get PR commit messages
      id: get_commits
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Get all commits from the merged PR
          const { data: commits } = await github.rest.pulls.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.payload.pull_request.number
          });

          console.log(`üìä Found ${commits.length} commits in PR #${context.payload.pull_request.number}`);

          // Extract commit messages
          let commitMessages = '';
          commits.forEach(commit => {
            const msg = commit.commit.message;
            const author = commit.commit.author.name;
            const sha = commit.sha.substring(0, 7);

            // Skip merge commits
            if (!msg.startsWith('Merge')) {
              commitMessages += `[${sha}] ${author}: ${msg}\n\n`;
            }
          });

          // Write to file for AI processing
          fs.writeFileSync('commit_messages.txt', commitMessages);
          console.log('‚úÖ Collected commit messages');

    - name: Generate AI-powered changelog
      id: ai_summary
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        PR_TITLE: ${{ github.event.pull_request.title }}
        PR_BODY: ${{ github.event.pull_request.body }}
        PR_URL: ${{ github.event.pull_request.html_url }}
      run: |
        python scripts/workflows/generate_changelog_ai.py
      continue-on-error: true

    - name: Fallback to manual categorization
      if: always()
      id: manual_categorize
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Check if AI summary already exists
          try {
            const existing = fs.readFileSync('changelog_entry.txt', 'utf8');
            if (existing && existing.trim()) {
              console.log('‚úÖ Using AI-generated changelog');
              return;
            }
          } catch (e) {
            // File doesn't exist, continue with manual categorization
          }

          console.log('üìù Falling back to manual commit categorization');

          // Get all commits from the merged PR
          const { data: commits } = await github.rest.pulls.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.payload.pull_request.number
          });

          console.log(`üìä Found ${commits.length} commits in PR`);

          // Extract and categorize commit messages
          const features = [];
          const fixes = [];
          const docs = [];
          const chores = [];
          const others = [];

          commits.forEach(commit => {
            const msg = commit.commit.message.split('\n')[0];
            const msgLower = msg.toLowerCase();

            if (msg.startsWith('Merge') || msg.includes('[skip ci]') || msg.includes('chore: update version metadata')) {
              return;
            }

            if (msgLower.startsWith('feat:') || msgLower.startsWith('feature:') || msgLower.includes('add ')) {
              features.push(msg.replace(/^feat:\s*/i, '').replace(/^feature:\s*/i, ''));
            } else if (msgLower.startsWith('fix:') || msgLower.includes('fix ') || msgLower.includes('bug')) {
              fixes.push(msg.replace(/^fix:\s*/i, ''));
            } else if (msgLower.startsWith('docs:') || msgLower.includes('documentation')) {
              docs.push(msg.replace(/^docs:\s*/i, ''));
            } else if (msgLower.startsWith('chore:') || msgLower.startsWith('ci:') || msgLower.startsWith('build:')) {
              chores.push(msg.replace(/^(chore|ci|build):\s*/i, ''));
            } else {
              others.push(msg);
            }
          });

          let changelog = '';

          if (features.length > 0) {
            changelog += '\n### ‚ú® Features\n\n';
            features.forEach(f => changelog += `- ${f}\n`);
          }

          if (fixes.length > 0) {
            changelog += '\n### üêõ Bug Fixes\n\n';
            fixes.forEach(f => changelog += `- ${f}\n`);
          }

          if (docs.length > 0) {
            changelog += '\n### üìö Documentation\n\n';
            docs.forEach(d => changelog += `- ${d}\n`);
          }

          if (chores.length > 0) {
            changelog += '\n### üîß Chores & Improvements\n\n';
            chores.forEach(c => changelog += `- ${c}\n`);
          }

          if (others.length > 0) {
            changelog += '\n### üîÑ Other Changes\n\n';
            others.forEach(o => changelog += `- ${o}\n`);
          }

          if (!changelog.trim()) {
            changelog = `\n### üîÑ Changes\n\n- Merged PR #${context.payload.pull_request.number}: ${context.payload.pull_request.title}\n`;
          }

          changelog += `\n**Full Changelog**: ${context.payload.pull_request.html_url}\n`;

          fs.writeFileSync('changelog_entry.txt', changelog);
          console.log('‚úÖ Generated manual changelog entry');
          console.log(changelog);

    - name: Update CHANGELOG.md
      id: update
      run: |
        python << 'EOF'
        import re
        from datetime import datetime

        # Read current changelog
        with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
            content = f.read()

        # Read generated entry
        with open('changelog_entry.txt', 'r', encoding='utf-8') as f:
            new_entry = f.read()

        version = "${{ steps.get_version.outputs.version }}"
        today = datetime.now().strftime("%Y-%m-%d")

        # Find the unreleased section or the first version section
        # We want to add to the current version's section
        version_base = version.split('+')[0]  # Strip commit hash if present

        # Look for existing version header
        version_pattern = rf'## \[{re.escape(version_base)}[^\]]*\]'
        version_match = re.search(version_pattern, content)

        if version_match:
            # Find the position after the version header line
            header_end = content.find('\n', version_match.end())

            # Check if there's already content - if so, append to it
            next_section = re.search(r'\n## \[', content[header_end:])
            if next_section:
                insert_pos = header_end + next_section.start()
            else:
                insert_pos = len(content)

            # Insert the new entry
            new_content = content[:insert_pos] + '\n' + new_entry + '\n' + content[insert_pos:]

        else:
            # Version doesn't exist yet - create new section
            # Find where to insert (after "## Unreleased" or at the beginning)
            unreleased_match = re.search(r'## \[Unreleased\].*?\n', content)

            if unreleased_match:
                insert_pos = unreleased_match.end()
            else:
                # Insert after the first heading
                first_heading = re.search(r'^# .*?\n', content, re.MULTILINE)
                insert_pos = first_heading.end() if first_heading else 0

            new_section = f'\n## [{version_base}] - {today}\n{new_entry}\n'
            new_content = content[:insert_pos] + new_section + content[insert_pos:]

        # Write back
        with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
            f.write(new_content)

        print(f"‚úÖ Updated CHANGELOG.md for version {version_base}")
        EOF

    - name: Check if changes were made
      id: check_changes
      run: |
        if git diff --quiet CHANGELOG.md; then
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è  No changes to CHANGELOG.md"
        else
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ CHANGELOG.md was updated"
        fi

    - name: Commit changelog updates
      if: steps.check_changes.outputs.changed == 'true'
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        git add CHANGELOG.md
        git commit -m "docs: update CHANGELOG.md for PR #${{ github.event.pull_request.number }} [skip ci]"

        # Pull with rebase to handle concurrent updates
        git pull --rebase origin staging

        # Push changes (retry up to 3 times if there are conflicts)
        for i in {1..3}; do
          if git push origin staging; then
            echo "‚úÖ Successfully pushed changelog update"
            break
          else
            echo "‚ö†Ô∏è  Push failed, attempt $i/3. Pulling latest changes..."
            git pull --rebase origin staging
            if [ $i -eq 3 ]; then
              echo "‚ùå Failed to push after 3 attempts"
              exit 1
            fi
          fi
        done

    - name: Summary
      if: always()
      run: |
        echo "=========================================="
        echo "CHANGELOG UPDATE SUMMARY"
        echo "=========================================="
        echo "PR: #${{ github.event.pull_request.number }}"
        echo "Version: ${{ steps.get_version.outputs.version }}"
        if [ "${{ steps.check_changes.outputs.changed }}" == "true" ]; then
          echo "Status: ‚úÖ CHANGELOG.md updated"
        else
          echo "Status: ‚ÑπÔ∏è  No changes needed"
        fi
        echo "=========================================="
