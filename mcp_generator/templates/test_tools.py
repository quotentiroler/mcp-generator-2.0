"""
Template generation for tool validation tests.

Generates pytest tests for validating MCP tool discovery.
"""


from ..models import ApiMetadata, ModuleSpec, SecurityConfig


def generate_tool_tests(
    modules: dict[str, ModuleSpec],
    api_metadata: ApiMetadata,
    security_config: SecurityConfig
) -> str:
    """
    Generate basic tests for tool validation.
    
    Args:
        modules: Generated server modules
        api_metadata: API metadata
        security_config: Security configuration
        
    Returns:
        Test file content for tool validation
    """

    # Collect module info for tools
    module_count = len(modules)
    total_tools = sum(spec.tool_count for spec in modules.values())
    first_module = list(modules.values())[0].api_var_name.replace('_api', '') if modules else 'admin'
    sample_tool = f"{first_module}_list"  # Generic sample tool name

    # Always generate simple tests for tools/list since it's an MCP protocol operation
    # that should always be publicly discoverable (even if some tools require auth)
    return f'''"""
Generated Tool Tests for {api_metadata.title}

Basic validation tests for all generated MCP tools.
Tools/list is always public - individual tools may require authentication when called.

Generated by mcp_generator - DO NOT EDIT MANUALLY
"""

import pytest
import httpx
import os


@pytest.fixture
def mcp_server_url():
    """MCP Server URL."""
    return os.getenv("MCP_SERVER_URL", "http://localhost:8000/mcp")


@pytest.fixture
async def mcp_client(mcp_server_url):
    """Create an HTTP client for MCP server."""
    # Check if server is running
    try:
        async with httpx.AsyncClient(timeout=2.0) as client:
            response = await client.get(mcp_server_url.replace('/mcp', '/health'), timeout=2.0)
    except (httpx.ConnectError, httpx.TimeoutException):
        pytest.skip("MCP server not available at {{mcp_server_url}}")
    
    async with httpx.AsyncClient(timeout=10.0) as client:
        # Initialize MCP session
        init_response = await client.post(
            mcp_server_url,
            json={{
                "jsonrpc": "2.0",
                "id": "init",
                "method": "initialize",
                "params": {{
                    "protocolVersion": "2025-03-26",
                    "capabilities": {{}},
                    "clientInfo": {{"name": "test", "version": "1.0"}}
                }}
            }},
            headers={{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }}
        )
        
        # Extract session ID if present
        session_id = init_response.headers.get("mcp-session-id")
        
        # Send initialized notification to complete handshake
        await client.post(
            mcp_server_url,
            json={{
                "jsonrpc": "2.0",
                "method": "notifications/initialized"
            }},
            headers={{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream",
                "mcp-session-id": session_id
            }} if session_id else {{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }}
        )
        
        yield client, mcp_server_url, session_id


class TestToolDiscovery:
    """Test tool discovery and listing."""
    
    @pytest.mark.asyncio
    async def test_tools_list_returns_all_tools(self, mcp_client):
        """Test that tools/list returns all {total_tools} generated tools."""
        client, mcp_server_url, session_id = mcp_client
        
        headers = {{
            "Content-Type": "application/json",
            "Accept": "application/json, text/event-stream"
        }}
        if session_id:
            headers["mcp-session-id"] = session_id
        
        response = await client.post(
            mcp_server_url,
            json={{
                "jsonrpc": "2.0",
                "id": "test",
                "method": "tools/list",
                "params": {{}}
            }},
            headers=headers
        )
        
        assert response.status_code == 200
        
        # Parse response (may be SSE or JSON)
        data = {{}}
        if response.headers.get("content-type", "").startswith("text/event-stream"):
            # Parse SSE response
            import json
            for line in response.text.split('\\n'):
                if line.startswith('data: '):
                    data = json.loads(line[6:])
                    break
        else:
            data = response.json()
        
        assert "result" in data
        assert "tools" in data["result"]
        
        tools = data["result"]["tools"]
        tool_names = [t["name"] for t in tools]
        
        # Check we have the expected number of tools
        assert len(tools) == {total_tools}, f"Expected {total_tools} tools, got {{len(tools)}}"
        
        print(f"\\nFound {{len(tools)}} tools:")
        for name in sorted(tool_names):
            print(f"  - {{name}}")


# Run instructions
if __name__ == "__main__":
    print("""
    Tool Validation Tests for {api_metadata.title}
    {"="*60}
    
    These tests validate that all {total_tools} generated tools are discoverable.
    Note: tools/list is always public, but individual tools may require authentication.
    
    Prerequisites:
    1. MCP Server running on http://localhost:8000 (or set MCP_SERVER_URL)
    
    Run tests:
        pytest test_tools_generated.py -v
    
    Start the server:
        cd generated_mcp && python {api_metadata.title.lower().replace(' ', '_')}_mcp_generated.py --transport=http
    """)
'''
