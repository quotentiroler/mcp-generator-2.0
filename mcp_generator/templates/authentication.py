"""
Template generation for authentication middleware.

Generates FastMCP middleware for JWT authentication and API client context.
"""

from ..models import ApiMetadata, SecurityConfig


def generate_authentication_middleware(api_metadata: ApiMetadata, security_config: SecurityConfig) -> str:
    """Generate the authentication middleware module."""
    backend_url = api_metadata.backend_url

    required_scopes = security_config.default_scopes or []
    scopes_literal = ", ".join(f'"{scope}"' for scope in required_scopes)
    scopes_comment = ', '.join(required_scopes) if required_scopes else 'none'

    jwks_uri = security_config.get_jwks_uri(backend_url)
    issuer = security_config.get_issuer(backend_url)
    audience = security_config.get_audience()

    # Build OAuth config documentation (as Python comments)
    oauth_doc = ""
    if security_config.oauth_config:
        oauth = security_config.oauth_config
        oauth_doc = f"""#
# OAuth2 Configuration (from OpenAPI spec):
# - Available flows: {', '.join(oauth.flows.keys())}
# - Available scopes: {', '.join(oauth.all_scopes.keys())}"""
        for flow_type, flow_def in oauth.flows.items():
            if flow_def.authorization_url:
                oauth_doc += f"\n# - {flow_type} authorization: {flow_def.authorization_url}"
            if flow_def.token_url:
                oauth_doc += f"\n# - {flow_type} token: {flow_def.token_url}"

    return f'''"""
JWT authentication utilities for MCP server.

Provides:
    - ApiClientContextMiddleware - attaches an authenticated ApiClient to the MCP context.
    - JWTAuthenticationBackend - Starlette backend that validates Bearer tokens with JWTVerifier.

Auto-generated by mcp_generator.
DO NOT EDIT MANUALLY - regenerate using: python -m mcp_generator
"""

import logging
import os
from typing import Optional
import sys
from pathlib import Path

from fastmcp.server.middleware import Middleware, MiddlewareContext
from fastmcp.server.auth import JWTVerifier, AccessToken
from starlette.authentication import AuthCredentials, AuthenticationBackend, SimpleUser
from starlette.requests import HTTPConnection
from mcp import McpError
from mcp.types import ErrorData

# Add the mcp-server folder to the Python path so we can import from generated/
mcp_server_path = Path(__file__).parent.parent.parent
if str(mcp_server_path) not in sys.path:
    sys.path.insert(0, str(mcp_server_path))

from generated_openapi.openapi_client import ApiClient, Configuration

logger = logging.getLogger(__name__)

# Backend API URL (extracted from OpenAPI spec during generation)
BACKEND_API_URL = "{backend_url}"

# Security configuration (extracted during generation)
# JWKS URI: {jwks_uri}
# Issuer: {issuer}
# Audience: {audience}
# Required scopes: {scopes_comment}
{oauth_doc}


class AuthenticatedIdentity(SimpleUser):
    """Starlette user wrapper that keeps the validated access token."""

    def __init__(self, access_token: AccessToken):
        subject = access_token.client_id or access_token.claims.get("sub") or "anonymous"
        super().__init__(subject)
        self.token = access_token
        self.scopes = access_token.scopes or []


class JWTAuthenticationBackend(AuthenticationBackend):
    """Starlette authentication backend that validates Bearer tokens via JWTVerifier."""

    def __init__(self, token_verifier: JWTVerifier, require_auth: bool = False):
        self._token_verifier = token_verifier
        self._require_auth = require_auth

    async def authenticate(self, conn: HTTPConnection):
        from starlette.authentication import AuthenticationError
        
        auth_header = None
        for key, value in conn.headers.items():
            if key.lower() == "authorization":
                auth_header = value
                break

        if not auth_header or not auth_header.lower().startswith("bearer "):
            if self._require_auth:
                # Raise AuthenticationError to trigger 401 response
                raise AuthenticationError("Authentication required")
            return None

        token = auth_header[7:]

        try:
            access_token = await self._token_verifier.verify_token(token)
        except Exception as exc:
            logger.warning("Token verification failed: %s", exc)
            if self._require_auth:
                raise AuthenticationError("Invalid token")
            return None

        if not access_token:
            if self._require_auth:
                raise AuthenticationError("Invalid token")
            return None

        identity = AuthenticatedIdentity(access_token)
        return AuthCredentials(identity.scopes), identity


class ApiClientContextMiddleware(Middleware):
    """Attach an authenticated ApiClient to FastMCP request context."""

    def __init__(
        self,
        transport_mode: str = "stdio",
        *,
        validate_tokens: bool = False,
        token_verifier: Optional[JWTVerifier] = None,
    ) -> None:
        self.transport_mode = transport_mode
        self.validate_tokens = validate_tokens
        self._stdio_client: Optional[ApiClient] = None
        self._jwt_verifier: Optional[JWTVerifier] = token_verifier

        if validate_tokens and self._jwt_verifier is None:
            try:
                self._jwt_verifier = JWTVerifier(
                    jwks_uri="{jwks_uri}",
                    issuer="{issuer}",
                    audience="{audience}",
                    required_scopes=[{scopes_literal}]
                )
                logger.info("Initialized inline JWT verifier for ApiClientContextMiddleware")
            except Exception as exc:
                logger.warning("Failed to initialize JWT verifier: %s", exc)
                self._jwt_verifier = None

    async def _validate(self, token: str) -> Optional[AccessToken]:
        if not self._jwt_verifier:
            return None

        try:
            return await self._jwt_verifier.verify_token(token)
        except Exception as exc:
            logger.warning("Token validation error: %s", exc)
            return None

    def _get_stdio_client(self) -> ApiClient:
        if self._stdio_client is None:
            config = Configuration(host=BACKEND_API_URL)
            token = os.getenv("BACKEND_API_TOKEN")

            if token:
                config.access_token = token
            else:
                logger.warning("BACKEND_API_TOKEN not set for STDIO transport")

            self._stdio_client = ApiClient(configuration=config)

        return self._stdio_client

    def _build_http_client(self, context: MiddlewareContext) -> ApiClient:
        config = Configuration(host=BACKEND_API_URL)
        token = None

        fastmcp_ctx = getattr(context, "fastmcp_context", None)
        if fastmcp_ctx and hasattr(fastmcp_ctx, "request_context"):
            request_ctx = fastmcp_ctx.request_context
            headers = getattr(request_ctx, "headers", {{}})
            auth_header = headers.get("authorization") or headers.get("Authorization")
            if isinstance(auth_header, str) and auth_header.startswith("Bearer "):
                token = auth_header[7:]

        if token:
            config.access_token = token
        else:
            logger.warning("HTTP request missing Bearer token; backend might enforce auth")

        return ApiClient(configuration=config)

    async def on_request(self, context: MiddlewareContext, call_next):
        try:
            token: Optional[str] = None

            if self.transport_mode == "stdio":
                token = os.getenv("BACKEND_API_TOKEN")
                if not token:
                    logger.warning("No BACKEND_API_TOKEN configured for STDIO transport")
                openapi_client = self._get_stdio_client()
            else:
                openapi_client = self._build_http_client(context)
                token = getattr(openapi_client.configuration, "access_token", None)

            if token and self.validate_tokens:
                access_token = await self._validate(token)
                if not access_token:
                    raise McpError(ErrorData(code=-32001, message="Invalid or expired authentication token"))

                fastmcp_ctx = getattr(context, "fastmcp_context", None)
                if fastmcp_ctx:
                    fastmcp_ctx.set_state("access_token", access_token)

            fastmcp_ctx = getattr(context, "fastmcp_context", None)
            if fastmcp_ctx:
                fastmcp_ctx.set_state("openapi_client",openapi_client)
            else:
                logger.warning("FastMCP context missing; unable to attach ApiClient")

            return await call_next(context)

        except McpError:
            raise
        except Exception as exc:
            logger.error("Authentication pipeline error: %s", exc)
            raise McpError(ErrorData(code=-32001, message=f"Authentication failed: {{exc}}"))
'''
