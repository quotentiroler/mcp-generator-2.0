"""
Template generation for HTTP basic E2E tests.

Generates pytest tests for core MCP protocol operations over HTTP transport:
- Server boot and readiness
- MCP protocol handshake (initialize → notifications/initialized)
- SSE vs JSON response format handling
- Session ID tracking
- Error scenarios
"""

from ...models import ApiMetadata, ModuleSpec, SecurityConfig


def generate_http_basic_tests(
    api_metadata: ApiMetadata,
    security_config: SecurityConfig,
    modules: dict[str, ModuleSpec],
) -> str:
    """
    Generate HTTP basic E2E tests.

    Args:
        api_metadata: API metadata
        security_config: Security configuration
        modules: Generated server modules

    Returns:
        Complete test file content
    """

    total_tools = sum(spec.tool_count for spec in modules.values())

    code = f'''"""
Generated HTTP Basic E2E Tests for {api_metadata.title}

Tests core MCP protocol operations over HTTP transport:
- Server boot and health/readiness
- MCP initialize/initialized handshake
- SSE vs JSON response formats
- Session ID management
- Error handling

Generated by mcp_generator - DO NOT EDIT MANUALLY
"""

import pytest
import httpx
import os
import json
import time


@pytest.fixture
def mcp_server_url():
    """MCP Server URL."""
    return os.getenv("MCP_SERVER_URL", "http://localhost:8000/mcp")


@pytest.fixture
def mcp_server_base():
    """MCP Server base URL (without /mcp path)."""
    url = os.getenv("MCP_SERVER_URL", "http://localhost:8000/mcp")
    return url.replace("/mcp", "")


class TestServerBoot:
    """Test server boot and readiness."""

    @pytest.mark.asyncio
    async def test_server_is_reachable(self, mcp_server_url):
        """Test that server is reachable and responding."""
        async with httpx.AsyncClient(timeout=5.0) as client:
            # Try a simple request to verify server is up
            try:
                response = await client.options(mcp_server_url)
                # OPTIONS may return 405 (Method Not Allowed) but that's OK - server is up
                assert response.status_code in [200, 405]
                print(f"\\n✓ Server is reachable at {{mcp_server_url}}")
            except httpx.ConnectError:
                pytest.fail(f"Server not reachable at {{mcp_server_url}}")

    @pytest.mark.asyncio
    async def test_health_endpoint_if_available(self, mcp_server_base):
        """Test health endpoint if it exists."""
        async with httpx.AsyncClient(timeout=5.0) as client:
            health_url = f"{{mcp_server_base}}/health"
            try:
                response = await client.get(health_url)
                if response.status_code == 200:
                    print(f"\\n✓ Health endpoint available at {{health_url}}")
                    # Health endpoints typically return JSON
                    if "json" in response.headers.get("content-type", ""):
                        data = response.json()
                        print(f"  Health data: {{data}}")
                elif response.status_code == 404:
                    print(f"\\n⚠ No health endpoint at {{health_url}} (this is optional)")
                else:
                    print(f"\\n⚠ Health endpoint returned {{response.status_code}}")
            except Exception as e:
                print(f"\\n⚠ Health check error: {{e}} (health endpoint is optional)")


class TestMCPHandshake:
    """Test MCP protocol handshake."""

    @pytest.mark.asyncio
    async def test_initialize_method(self, mcp_server_url):
        """Test MCP initialize method."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-init-1",
                    "method": "initialize",
                    "params": {{
                        "protocolVersion": "2025-03-26",
                        "capabilities": {{}},
                        "clientInfo": {{
                            "name": "test-client",
                            "version": "1.0"
                        }}
                    }}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            assert response.status_code == 200

            # Check response format (SSE or JSON)
            content_type = response.headers.get("content-type", "")

            if content_type.startswith("text/event-stream"):
                print("\\n✓ Server returned SSE format")
                # Parse SSE response
                data = None
                for line in response.text.split('\\n'):
                    if line.startswith('data: '):
                        data = json.loads(line[6:])
                        break
                assert data is not None, "No data in SSE stream"
            else:
                print("\\n✓ Server returned JSON format")
                data = response.json()

            # Validate initialize response
            # Note: Some servers require the full handshake (initialize + notifications/initialized)
            # and may reject incomplete handshakes with -32602 (Invalid request parameters)
            if "result" in data:
                # Server accepts incomplete handshake - validate the result
                result = data["result"]
                assert "protocolVersion" in result
                assert "serverInfo" in result
                assert "capabilities" in result
                print(f"  Protocol version: {{result['protocolVersion']}}")
                print(f"  Server: {{result['serverInfo']['name']}} v{{result['serverInfo']['version']}}")
            elif "error" in data and data["error"].get("code") == -32602:
                # Server enforces complete handshake protocol - this is acceptable
                print(f"\\n✓ Server requires complete handshake (initialize + notifications/initialized)")
                print(f"  Error: {{data['error'].get('message', 'Invalid request parameters')}}")
            else:
                # Unexpected response format
                pytest.fail(f"Unexpected response: {{data}}")

    @pytest.mark.asyncio
    async def test_initialize_with_session_tracking(self, mcp_server_url):
        """Test that server assigns and tracks session IDs."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-init-2",
                    "method": "initialize",
                    "params": {{
                        "protocolVersion": "2025-03-26",
                        "capabilities": {{}},
                        "clientInfo": {{"name": "test", "version": "1.0"}}
                    }}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            # Check for session ID header
            session_id = response.headers.get("mcp-session-id")
            if session_id:
                print(f"\\n✓ Server assigned session ID: {{session_id}}")

                # Use session ID in follow-up request
                tools_response = await client.post(
                    mcp_server_url,
                    json={{
                        "jsonrpc": "2.0",
                        "id": "test-tools",
                        "method": "tools/list",
                        "params": {{}}
                    }},
                    headers={{
                        "Content-Type": "application/json",
                        "Accept": "application/json, text/event-stream",
                        "mcp-session-id": session_id
                    }}
                )

                assert tools_response.status_code == 200
                print(f"  ✓ Session ID accepted in follow-up request")
            else:
                print("\\n⚠ No session ID assigned (server may be stateless)")

    @pytest.mark.asyncio
    async def test_full_handshake_sequence(self, mcp_server_url):
        """Test complete MCP handshake: initialize → notifications/initialized."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Step 1: Initialize
            init_response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "init",
                    "method": "initialize",
                    "params": {{
                        "protocolVersion": "2025-03-26",
                        "capabilities": {{}},
                        "clientInfo": {{"name": "test", "version": "1.0"}}
                    }}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            assert init_response.status_code == 200
            session_id = init_response.headers.get("mcp-session-id")

            # Step 2: Send initialized notification
            headers = {{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }}
            if session_id:
                headers["mcp-session-id"] = session_id

            notif_response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "method": "notifications/initialized"
                }},
                headers=headers
            )

            # Notifications can return 200, 202 (Accepted), or 204 (No Content)
            assert notif_response.status_code in [200, 202, 204]
            print("\\n✓ Full handshake completed: initialize → notifications/initialized")


class TestResponseFormats:
    """Test SSE vs JSON response format handling."""

    @pytest.mark.asyncio
    async def test_sse_response_format(self, mcp_server_url):
        """Test Server-Sent Events response format."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-sse",
                    "method": "tools/list",
                    "params": {{}}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "text/event-stream"
                }}
            )

            content_type = response.headers.get("content-type", "")

            # Server may return SSE or fallback to JSON
            if content_type.startswith("text/event-stream"):
                print("\\n✓ SSE format returned")

                # Parse SSE
                events = []
                for line in response.text.split('\\n'):
                    if line.startswith('data: '):
                        events.append(json.loads(line[6:]))

                assert len(events) > 0
                print(f"  Parsed {{len(events)}} SSE event(s)")
            else:
                print("\\n⚠ Server returned JSON instead of SSE (fallback behavior)")

    @pytest.mark.asyncio
    async def test_json_response_format(self, mcp_server_url):
        """Test plain JSON response format."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Initialize first
            init_response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "init",
                    "method": "initialize",
                    "params": {{
                        "protocolVersion": "2025-03-26",
                        "capabilities": {{}},
                        "clientInfo": {{"name": "test", "version": "1.0"}}
                    }}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            session_id = init_response.headers.get("mcp-session-id")
            headers = {{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }}
            if session_id:
                headers["mcp-session-id"] = session_id

            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-json",
                    "method": "tools/list",
                    "params": {{}}
                }},
                headers=headers
            )

            assert response.status_code == 200

            content_type = response.headers.get("content-type", "")

            # Should get JSON when we request it
            if "json" in content_type:
                print("\\n✓ JSON format returned as requested")
                data = response.json()
                assert "jsonrpc" in data
                assert data["jsonrpc"] == "2.0"
            else:
                print(f"\\n⚠ Got {{content_type}} instead of JSON")


class TestErrorScenarios:
    """Test error handling."""

    @pytest.mark.asyncio
    async def test_malformed_json_request(self, mcp_server_url):
        """Test server handles malformed JSON gracefully."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                content="{{invalid json",
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            # Server should return 400 or JSON-RPC error
            assert response.status_code in [400, 200]

            if response.status_code == 200:
                # JSON-RPC error response
                data = response.json()
                assert "error" in data
                print(f"\\n✓ Malformed JSON returned JSON-RPC error: {{data['error']['message']}}")
            else:
                print(f"\\n✓ Malformed JSON returned HTTP {{response.status_code}}")

    @pytest.mark.asyncio
    async def test_invalid_method(self, mcp_server_url):
        """Test server handles unknown methods."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-invalid",
                    "method": "invalid/method/does/not/exist",
                    "params": {{}}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            # Should return JSON-RPC error or 404/405
            if response.status_code == 200:
                data = response.json()
                assert "error" in data
                assert data["error"]["code"] in [-32601, -32600]  # Method not found or invalid request
                print(f"\\n✓ Invalid method returned error code {{data['error']['code']}}")
            else:
                print(f"\\n✓ Invalid method returned HTTP {{response.status_code}}")

    @pytest.mark.asyncio
    async def test_missing_required_params(self, mcp_server_url):
        """Test server validates required parameters."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "test-params",
                    "method": "initialize"
                    # Missing required params
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            # Should return error (200 with error payload or 400/422 status)
            if response.status_code == 200:
                # Try to parse JSON response
                try:
                    data = response.json()
                    assert "error" in data
                    print(f"\\n✓ Missing params returned error: {{data['error']['message']}}")
                except Exception:
                    # Empty or invalid response body
                    print(f"\\n✓ Missing params returned 200 with empty/invalid body")
            else:
                assert response.status_code in [400, 422]
                print(f"\\n✓ Missing params returned HTTP {{response.status_code}}")


class TestToolsEndpoint:
    """Test tools/list endpoint."""

    @pytest.mark.asyncio
    async def test_tools_list_returns_expected_count(self, mcp_server_url):
        """Verify tools/list returns the expected number of tools."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            # Initialize first
            init_response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "init",
                    "method": "initialize",
                    "params": {{
                        "protocolVersion": "2025-03-26",
                        "capabilities": {{}},
                        "clientInfo": {{"name": "test", "version": "1.0"}}
                    }}
                }},
                headers={{
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }}
            )

            session_id = init_response.headers.get("mcp-session-id")
            headers = {{
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }}
            if session_id:
                headers["mcp-session-id"] = session_id

            # Send initialized notification to complete handshake
            await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "method": "notifications/initialized"
                }},
                headers=headers
            )

            # Now list tools
            response = await client.post(
                mcp_server_url,
                json={{
                    "jsonrpc": "2.0",
                    "id": "tools",
                    "method": "tools/list",
                    "params": {{}}
                }},
                headers=headers
            )

            assert response.status_code == 200

            # Parse response
            if response.headers.get("content-type", "").startswith("text/event-stream"):
                data = None
                for line in response.text.split('\\n'):
                    if line.startswith('data: '):
                        data = json.loads(line[6:])
                        break
            else:
                data = response.json()

            assert "result" in data
            assert "tools" in data["result"]

            tools = data["result"]["tools"]
            assert len(tools) == {total_tools}

            print(f"\\n✓ tools/list returned {{len(tools)}} tools (expected {total_tools})")

            # Verify tool structure
            for tool in tools[:3]:  # Check first 3 tools
                assert "name" in tool
                assert "description" in tool or "inputSchema" in tool
                print(f"  - {{tool['name']}}")


# Summary
if __name__ == "__main__":
    print("""
    HTTP Basic E2E Tests for {api_metadata.title}
    {"=" * 60}

    Tests:
    ✓ Server boot and reachability
    ✓ MCP protocol handshake (initialize → initialized)
    ✓ Session ID tracking
    ✓ Response format handling (SSE vs JSON)
    ✓ Error scenarios (malformed requests, invalid methods)
    ✓ Basic tools/list validation

    Run tests:
        pytest test_e2e_http_basic_generated.py -v
    """)
'''

    return code
