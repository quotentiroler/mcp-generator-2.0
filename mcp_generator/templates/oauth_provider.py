"""
Template generation for OAuth provider configuration.

Generates FastMCP OAuth provider setup and ASGI middleware.
"""

from ..models import ApiMetadata, SecurityConfig


def generate_oauth_provider(api_metadata: ApiMetadata, security_config: SecurityConfig) -> str:
    """Generate OAuth provider configuration."""
    backend_url = api_metadata.backend_url
    default_scopes = security_config.default_scopes
    scopes_str = ", ".join(f'"{s}"' for s in default_scopes)

    jwks_uri = security_config.get_jwks_uri(backend_url)
    issuer = security_config.get_issuer(backend_url)
    audience = security_config.get_audience()

    return f'''"""
OAuth helper utilities for MCP server.

Provides helpers to:
    - Advertise backend OAuth endpoints via RemoteAuthProvider.
    - Build Starlette authentication middleware for HTTP transport.
    - Persist OAuth tokens using pluggable storage backend (if available).
    - RFC 7662 token introspection support.

Auto-generated by mcp_generator.
DO NOT EDIT MANUALLY - regenerate using: python -m mcp_generator
"""

import json
import logging
import time
from typing import Any, Optional

from fastmcp.server.auth import RemoteAuthProvider, JWTVerifier
from starlette.middleware import Middleware as ASGIMiddleware
from starlette.middleware.authentication import AuthenticationMiddleware
from starlette.types import Receive, Scope, Send
from pydantic import AnyHttpUrl

from .authentication import JWTAuthenticationBackend, AuthenticatedIdentity

# Try to import storage for token persistence
try:
    from storage import get_storage, TokenStore
    STORAGE_AVAILABLE = True
except ImportError:
    STORAGE_AVAILABLE = False
    TokenStore = None  # type: ignore

logger = logging.getLogger(__name__)

# Backend API URL (extracted from OpenAPI spec during generation)
BACKEND_API_URL = "{backend_url}"


class OAuthTokenManager:
    """
    Manages OAuth token persistence and lifecycle.

    Integrates with pluggable storage backend to:
    - Store access and refresh tokens securely
    - Retrieve tokens by client_id or user_id
    - Handle token expiration and renewal
    - Support RFC 7662 token introspection
    """

    def __init__(self, storage_backend: Optional[Any] = None):
        """
        Initialize token manager.

        Args:
            storage_backend: StorageBackend instance (or None to disable persistence)
        """
        self.storage = storage_backend
        self.token_store = TokenStore(storage_backend) if storage_backend and STORAGE_AVAILABLE else None

        if self.token_store:
            logger.info("OAuth token persistence enabled via storage backend")
        else:
            logger.warning("OAuth token persistence disabled - tokens will not survive restarts")

    async def store_token(
        self,
        client_id: str,
        token_data: dict[str, Any],
        user_id: Optional[str] = None,
    ) -> bool:
        """
        Store OAuth token with metadata.

        Args:
            client_id: OAuth client identifier
            token_data: Token response from authorization server (access_token, refresh_token, etc.)
            user_id: Optional user identifier for user-specific tokens

        Returns:
            True if stored successfully, False otherwise
        """
        if not self.token_store:
            logger.debug("Token storage not available, skipping persistence")
            return False

        try:
            # Augment token data with metadata
            enriched_token = {{
                **token_data,
                "stored_at": int(time.time()),
                "user_id": user_id,
            }}

            await self.token_store.save_token(client_id, enriched_token)
            logger.info(f"Stored OAuth token for client: {{client_id}}")
            return True

        except Exception as e:
            logger.error(f"Failed to store token for {{client_id}}: {{e}}")
            return False

    async def get_token(self, client_id: str) -> Optional[dict[str, Any]]:
        """
        Retrieve stored OAuth token.

        Args:
            client_id: OAuth client identifier

        Returns:
            Token data dict or None if not found
        """
        if not self.token_store:
            return None

        try:
            token = await self.token_store.get_token(client_id)
            if token:
                logger.debug(f"Retrieved token for client: {{client_id}}")
            return token
        except Exception as e:
            logger.error(f"Failed to retrieve token for {{client_id}}: {{e}}")
            return None

    async def delete_token(self, client_id: str) -> bool:
        """
        Delete stored OAuth token (e.g., on logout or revocation).

        Args:
            client_id: OAuth client identifier

        Returns:
            True if deleted successfully, False otherwise
        """
        if not self.token_store:
            return False

        try:
            await self.token_store.delete_token(client_id)
            logger.info(f"Deleted token for client: {{client_id}}")
            return True
        except Exception as e:
            logger.error(f"Failed to delete token for {{client_id}}: {{e}}")
            return False

    async def introspect_token(
        self,
        token: str,
        introspection_endpoint: str,
        client_id: str,
        client_secret: str,
    ) -> Optional[dict[str, Any]]:
        """
        Introspect token using RFC 7662 endpoint.

        Args:
            token: Access token to introspect
            introspection_endpoint: OAuth server introspection URL
            client_id: OAuth client ID for authentication
            client_secret: OAuth client secret

        Returns:
            Introspection response dict or None on failure
        """
        try:
            import httpx

            response = await httpx.AsyncClient().post(
                introspection_endpoint,
                data={{"token": token}},
                auth=(client_id, client_secret),
                headers={{"Accept": "application/json"}},
                timeout=10.0,
            )

            if response.status_code == 200:
                introspection = response.json()
                logger.debug(f"Token introspection: active={{introspection.get('active')}}")
                return introspection
            else:
                logger.warning(f"Introspection failed: {{response.status_code}}")
                return None

        except Exception as e:
            logger.error(f"Token introspection error: {{e}}")
            return None


def get_token_manager(storage_backend: Optional[Any] = None) -> OAuthTokenManager:
    """
    Factory function to create OAuthTokenManager.

    Args:
        storage_backend: Optional StorageBackend instance

    Returns:
        Configured OAuthTokenManager

    Example:
        from storage import get_storage
        from oauth_provider import get_token_manager

        storage = get_storage("filesystem")
        token_manager = get_token_manager(storage)

        # Store token after OAuth flow
        await token_manager.store_token("client123", token_response)

        # Retrieve token later
        token = await token_manager.get_token("client123")
    """
    return OAuthTokenManager(storage_backend)


def build_authentication_stack(jwt_verifier: JWTVerifier, require_auth: bool = False) -> list[ASGIMiddleware]:
    """
    Return Starlette middleware configuration for JWT authentication.

    Args:
        jwt_verifier: JWTVerifier instance for token validation
        require_auth: If True, authentication backend will reject requests without valid tokens

    Returns:
        List of ASGI middleware
    """
    from starlette.responses import JSONResponse
    from starlette.requests import Request

    def on_auth_error(conn: Request, exc: Exception) -> JSONResponse:
        """Custom error handler that returns 401 instead of 400."""
        return JSONResponse(
            {{"error": "invalid_token", "error_description": str(exc)}},
            status_code=401,
            headers={{"WWW-Authenticate": 'Bearer error="invalid_token"'}}
        )

    backend = JWTAuthenticationBackend(jwt_verifier, require_auth=require_auth)
    return [ASGIMiddleware(AuthenticationMiddleware, backend=backend, on_error=on_auth_error)]


class RequireScopesMiddleware:
    """ASGI middleware that enforces presence of an authenticated user and scopes."""

    def __init__(
        self,
        app: Any,
        *,
        required_scopes: list[str],
        resource_metadata_url: Optional[AnyHttpUrl] = None,
    ) -> None:
        self.app = app
        self.required_scopes = required_scopes
        self.resource_metadata_url = resource_metadata_url

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        user = scope.get("user")
        if not isinstance(user, AuthenticatedIdentity):
            logger.warning("No authenticated user present on scope")
            await self._send_auth_error(
                send,
                status_code=401,
                error="invalid_token",
                description="Authentication required",
            )
            return

        if user.token and getattr(user.token, "expires_at", None):
            if user.token.expires_at < int(time.time()):
                logger.warning("Access token has expired")
                await self._send_auth_error(
                    send,
                    status_code=401,
                    error="invalid_token",
                    description="Token expired",
                )
                return

        granted = set(scope.get("auth", ()).scopes if scope.get("auth") else user.scopes)
        for required_scope in self.required_scopes:
            if required_scope not in granted:
                logger.warning("Missing required scope: %s", required_scope)
                await self._send_auth_error(
                    send,
                    status_code=403,
                    error="insufficient_scope",
                    description=f"Required scope: {{required_scope}}",
                )
                return

        await self.app(scope, receive, send)

    async def _send_auth_error(
        self,
        send: Send,
        *,
        status_code: int,
        error: str,
        description: str,
    ) -> None:
        www_auth_parts = [f'error="{{error}}"', f'error_description="{{description}}"']
        if self.resource_metadata_url:
            www_auth_parts.append(f'resource_metadata="{{self.resource_metadata_url}}"')

        headers = [
            (b"content-type", b"application/json"),
            (b"www-authenticate", f"Bearer {{', '.join(www_auth_parts)}}".encode()),
        ]

        body = json.dumps({{"error": error, "error_description": description}}).encode()
        headers.append((b"content-length", str(len(body)).encode()))

        await send({{
            "type": "http.response.start",
            "status": status_code,
            "headers": headers,
        }})
        await send({{"type": "http.response.body", "body": body}})


def create_remote_auth_provider(
    backend_url: Optional[str] = None,
    required_scopes: Optional[list[str]] = None,
) -> RemoteAuthProvider:
    """Create a RemoteAuthProvider for backend OAuth discovery."""

    backend_url = backend_url or BACKEND_API_URL
    required_scopes = required_scopes or [{scopes_str}]

    logger.info("Creating RemoteAuthProvider")
    logger.info("  Backend API: %s", backend_url)
    logger.info("  Required scopes: %s", required_scopes)

    jwt_verifier = JWTVerifier(
        jwks_uri="{jwks_uri}",
        issuer="{issuer}",
        audience="{audience}",
        required_scopes=required_scopes,
    )

    auth_provider = RemoteAuthProvider(
        token_verifier=jwt_verifier,
        authorization_servers=[AnyHttpUrl(backend_url)],
        base_url=AnyHttpUrl(backend_url),
        resource_name="MCP Server",
        resource_documentation=AnyHttpUrl(f"{{backend_url}}/docs"),
    )

    logger.info("RemoteAuthProvider created - OAuth metadata endpoints advertised")
    return auth_provider


def create_jwt_verifier(
    backend_url: Optional[str] = None,
    required_scopes: Optional[list[str]] = None,
) -> Optional[JWTVerifier]:
    """Create a standalone JWTVerifier for token validation."""

    backend_url = backend_url or BACKEND_API_URL
    scopes = required_scopes if required_scopes is not None else []

    try:
        logger.info("Creating JWTVerifier")
        logger.info("  JWKS URI: %s", "{jwks_uri}")
        logger.info("  Issuer: %s", "{issuer}")
        logger.info("  Audience: %s", "{audience}")
        logger.info("  Scopes: %s", scopes if scopes else "none")

        return JWTVerifier(
            jwks_uri="{jwks_uri}",
            issuer="{issuer}",
            audience="{audience}",
            required_scopes=scopes,
        )
    except Exception as exc:
        logger.error("Failed to create JWTVerifier: %s", exc)
        return None
'''
