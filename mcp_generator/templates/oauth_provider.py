"""
Template generation for OAuth provider configuration.

Generates FastMCP OAuth provider setup and ASGI middleware.
"""

from ..models import ApiMetadata, SecurityConfig


def generate_oauth_provider(api_metadata: ApiMetadata, security_config: SecurityConfig) -> str:
    """Generate OAuth provider configuration."""
    backend_url = api_metadata.backend_url
    default_scopes = security_config.default_scopes
    scopes_str = ", ".join(f'"{s}"' for s in default_scopes)

    jwks_uri = security_config.get_jwks_uri(backend_url)
    issuer = security_config.get_issuer(backend_url)
    audience = security_config.get_audience()

    return f'''"""
OAuth helper utilities for MCP server.

Provides helpers to:
    - Advertise backend OAuth endpoints via RemoteAuthProvider.
    - Build Starlette authentication middleware for HTTP transport.

Auto-generated by mcp_generator.
DO NOT EDIT MANUALLY - regenerate using: python -m mcp_generator
"""

import json
import logging
import time
from typing import Any, Optional

from fastmcp.server.auth import RemoteAuthProvider, JWTVerifier
from starlette.middleware import Middleware as ASGIMiddleware
from starlette.middleware.authentication import AuthenticationMiddleware
from starlette.types import Receive, Scope, Send
from pydantic import AnyHttpUrl

from .authentication import JWTAuthenticationBackend, AuthenticatedIdentity

logger = logging.getLogger(__name__)

# Backend API URL (extracted from OpenAPI spec during generation)
BACKEND_API_URL = "{backend_url}"


def build_authentication_stack(jwt_verifier: JWTVerifier, require_auth: bool = False) -> list[ASGIMiddleware]:
    """
    Return Starlette middleware configuration for JWT authentication.

    Args:
        jwt_verifier: JWTVerifier instance for token validation
        require_auth: If True, authentication backend will reject requests without valid tokens

    Returns:
        List of ASGI middleware
    """
    from starlette.responses import JSONResponse
    from starlette.requests import Request

    def on_auth_error(conn: Request, exc: Exception) -> JSONResponse:
        """Custom error handler that returns 401 instead of 400."""
        return JSONResponse(
            {{"error": "invalid_token", "error_description": str(exc)}},
            status_code=401,
            headers={{"WWW-Authenticate": 'Bearer error="invalid_token"'}}
        )

    backend = JWTAuthenticationBackend(jwt_verifier, require_auth=require_auth)
    return [ASGIMiddleware(AuthenticationMiddleware, backend=backend, on_error=on_auth_error)]


class RequireScopesMiddleware:
    """ASGI middleware that enforces presence of an authenticated user and scopes."""

    def __init__(
        self,
        app: Any,
        *,
        required_scopes: list[str],
        resource_metadata_url: Optional[AnyHttpUrl] = None,
    ) -> None:
        self.app = app
        self.required_scopes = required_scopes
        self.resource_metadata_url = resource_metadata_url

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        user = scope.get("user")
        if not isinstance(user, AuthenticatedIdentity):
            logger.warning("No authenticated user present on scope")
            await self._send_auth_error(
                send,
                status_code=401,
                error="invalid_token",
                description="Authentication required",
            )
            return

        if user.token and getattr(user.token, "expires_at", None):
            if user.token.expires_at < int(time.time()):
                logger.warning("Access token has expired")
                await self._send_auth_error(
                    send,
                    status_code=401,
                    error="invalid_token",
                    description="Token expired",
                )
                return

        granted = set(scope.get("auth", ()).scopes if scope.get("auth") else user.scopes)
        for required_scope in self.required_scopes:
            if required_scope not in granted:
                logger.warning("Missing required scope: %s", required_scope)
                await self._send_auth_error(
                    send,
                    status_code=403,
                    error="insufficient_scope",
                    description=f"Required scope: {{required_scope}}",
                )
                return

        await self.app(scope, receive, send)

    async def _send_auth_error(
        self,
        send: Send,
        *,
        status_code: int,
        error: str,
        description: str,
    ) -> None:
        www_auth_parts = [f'error="{{error}}"', f'error_description="{{description}}"']
        if self.resource_metadata_url:
            www_auth_parts.append(f'resource_metadata="{{self.resource_metadata_url}}"')

        headers = [
            (b"content-type", b"application/json"),
            (b"www-authenticate", f"Bearer {{', '.join(www_auth_parts)}}".encode()),
        ]

        body = json.dumps({{"error": error, "error_description": description}}).encode()
        headers.append((b"content-length", str(len(body)).encode()))

        await send({{
            "type": "http.response.start",
            "status": status_code,
            "headers": headers,
        }})
        await send({{"type": "http.response.body", "body": body}})


def create_remote_auth_provider(
    backend_url: Optional[str] = None,
    required_scopes: Optional[list[str]] = None,
) -> RemoteAuthProvider:
    """Create a RemoteAuthProvider for backend OAuth discovery."""

    backend_url = backend_url or BACKEND_API_URL
    required_scopes = required_scopes or [{scopes_str}]

    logger.info("Creating RemoteAuthProvider")
    logger.info("  Backend API: %s", backend_url)
    logger.info("  Required scopes: %s", required_scopes)

    jwt_verifier = JWTVerifier(
        jwks_uri="{jwks_uri}",
        issuer="{issuer}",
        audience="{audience}",
        required_scopes=required_scopes,
    )

    auth_provider = RemoteAuthProvider(
        token_verifier=jwt_verifier,
        authorization_servers=[AnyHttpUrl(backend_url)],
        base_url=AnyHttpUrl(backend_url),
        resource_name="MCP Server",
        resource_documentation=AnyHttpUrl(f"{{backend_url}}/docs"),
    )

    logger.info("RemoteAuthProvider created - OAuth metadata endpoints advertised")
    return auth_provider


def create_jwt_verifier(
    backend_url: Optional[str] = None,
    required_scopes: Optional[list[str]] = None,
) -> Optional[JWTVerifier]:
    """Create a standalone JWTVerifier for token validation."""

    backend_url = backend_url or BACKEND_API_URL
    scopes = required_scopes if required_scopes is not None else []

    try:
        logger.info("Creating JWTVerifier")
        logger.info("  JWKS URI: %s", "{jwks_uri}")
        logger.info("  Issuer: %s", "{issuer}")
        logger.info("  Audience: %s", "{audience}")
        logger.info("  Scopes: %s", scopes if scopes else "none")

        return JWTVerifier(
            jwks_uri="{jwks_uri}",
            issuer="{issuer}",
            audience="{audience}",
            required_scopes=scopes,
        )
    except Exception as exc:
        logger.error("Failed to create JWTVerifier: %s", exc)
        return None
'''
